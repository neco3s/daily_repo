
## 取り組んだ課題一覧

- :construction: タイピング、linuxWeb最強問題集10問、docker-docs1パート、読書 :tomato:1
- プロを目指す人のためのRuby入門を読む、感想をブログに書く、URLを提出 :tomato:8
- レビューして頂いた箇所の修正 :tomato:1
- オブジェクト指向Ruby 自販機問題 :tomato:14

## わかったこと

- クラスメソッドスコープ内のselfはクラスを表すがインスタンスメソッド内のselfはクラスのインスタンスを表す。
- クラスの継承が適切かどうか判断する方法の１つは、サブクラスはスーパークラスの一種であると声に出して読んだ時に違和感がないか確かめること
- 継承関係を確認したいときはis_a?(エイリアスメソッド kind_off?)を使用する
- superでスーパークラスのメソッドを呼び出す。superをメソッド内で記述すると、スーパークラスの同名メソッドを呼び出す。superを利用することでサブクラスではスーパークラスで用意されていない差分をコーディングするだけで目的の処理を実装できる
- メソッドのオーバーライド(上書き)
- public クラスの外部
- private クラスの内部、サブクラスで呼び出し可(privateキーワードをクラスの最後の方に一回だけ使うことが一般的)
- サブクラスでメソッドをオーバーライドすると、可視性も同時に変更できる
- クラスメソッドはprivateキーワードの下に定義してもprivateにならない(class << self, private_class_methodのどちらかでクラスメソッドの可視性をprivateとかにできる)
- privateキーワードは実際はメソッド、既存のメソッド名を渡すとそのメソッドがprivateメソッドになる
- Ruby3.0~ (private attr_accessor :name)
- protected 外部には公開したくないが、同じクラスやサブクラスの中であればレシーバー付きで呼び出せるようにしたい時に使用する。
- クラスを実装する場合はスーパークラスの実装を把握しておくことが望ましい
- 定数はクラスの外部から直接参照することも可能(クラス名::定数名)、private_constant :定数名 で定数を外部から参照不可にできる
- 定数の定義は必ずクラス構文の直下、もしくはトップレベルで行う必要がある(メソッド内にスコープを限定した定義不可)
- Rubyでは定数であっても変更しようと思えばできる
- freeze(凍結)キーワードを用いることで、定数への再代入や定数の値を破壊的に変更してしまうことを防ぐことができる
- イミュータブルなオブジェクト(数値、シンボル、true/false)はfreezeする必要がない(してもいいが意味がない)
- インスタンス変数はクラスをインスタンス化した際に、オブジェクトごとに管理される変数
- クラスインスタンス変数はインスタンスの作成とは無関係に、クラス自身が保持しているデータ(クラス構文の直下や、クラスメソッドの内部で@で始まる変数を操作すると、クラス変数にアクセスしていることになる)
- クラス変数 @@name クラスメソッド内でもインスタンスメソッド内でも参照できる :cherries:p294
- グローバル変数 ($で変数名を始める,プログラムのどこからでも代入、参照が可能)、
- 組み込み変数($で始まる幾つかの変数は「組み込み関数」や「特殊変数」としてRubyによって最初から用途が決められている):cherries:p295
- エイリアスメソッドの定義 :cherries:p297
- メソッドの削除 :cherries:p297
- 入れ子になったクラスの定義 :cherries:p298
- 演算子の挙動を独自に再定義する :cherries:p299
- 等値を判断するメソッドや演算子 :cherries:p301 (equal?,==,eql?,===)
- モンキーパッチ 既存の実装を上書きして、自分が期待する挙動に変更すること :cherries:p305
- 特異メソッド 特定のオブジェクトにだけ紐づくメソッドのこと :cherries:p307
- クラスメソッドは特異メソッドの一種 :cherries:p308
- Rubyは動的型付け言語なので抽象クラスやインターフェースといった機能はない。静的型付け言語では実行前にそのメソッドが100%確実に呼び出せることを保証しようとする。一方、動的型付け言語では実行時にそのメソッドが呼び出せるかどうか判断し、呼び出せない時にエラーが起きる。Rubyが気にするのは「実行するその瞬間に、そのメソッドが呼び出せるか否か」であって、「そのオブジェクトのクラス（データ型）が何か」ではない。
- ダックタイピング オブジェクトのクラスが何であろうとそのメソッドが呼び出せれば良しとするプログラミングスタイルのこと
- 動的型付け言語、静的型付け言語、それぞれの特徴や特性は扱う人の習熟度によってメリットにもなるしデメリットにもなりうる :cherries:p312
- 例外処理のベストプラクティス :cherries: p381
- 例外を捕捉して処理を続行する場合 :cherries: p369
- 例外処理の流れ:cherries: p369
- 例外オブジェクトから情報を取得する :cherries:p372
- クラスを指定して捕捉する例外を限定する :cherries:p373
- 例外クラスの継承関係を理解する :cherries:p374
- 他のプログラミング言語のExceptionクラスがRubyでいうところのStandardErrorクラスである。
- 継承関係とresucue節の順番に注意する :cherries:p375
- 永遠に実行されないrescue節を作らないためにはスーパークラスよりもサブクラスを手前に持ってくるようにする。
- StandardErrorとそのサブクラスを捕捉するのであれば`rescue` のみで良い(例外クラスを指定しない)
- 例外発生時にもう一度処理をやり直すretry :cherries:p378
- 無条件retryで無限ループを発生させないために、カウンタ変数でretryの回数を制限する。ネットワークエラーなどの一時的に発生している問題が例外の原因であれば何度かやり直すことで正常に実行できる可能性がある
- 意図的に例外を発生させる :cherries:p379
- 例外処理のベストプラクティス :cherries:p381
  - 安易にrescueを使わない
  - rescueした情報を残す
  - 例外処理の対象範囲と対象クラスを極力絞り込む
  - 例外処理よりも条件分岐を使う
  - 予期しない条件は異常終了させる
  - 例外処理も手を抜かずにテストする
- プログラミング初心者は「例外が発生したら即座に異常終了させよう」もしくは「フレームワークの共通処理に全部丸投げしよう」と考える方が安全。Railsでは例外発生時の共通処理が最初から組み込まれている
- 例外をrescueしたらその場で情報を残さないと詳細な情報が失われてしまう、手がかりが多いほど原因調査は楽になる
- 例外処理を書く場合は、例外が発生しそうな箇所と発生しそうな例外クラスをあらかじめ予測し、その予測を例外処理のコードに反映させる。
- 例外処理を書く前に公式リファレンスを読んで、問題の有無を事前に確認できるメソッドが用意されていないかチェックすべし
- ensure :cherries:p392 例外の有無に関わらず実行する処理
- ensureの代わりにブロックを使う :cherries:p393
- ファイル処理のように「使用したら必ずリソースを解放する」という処理はRubyではブロック付きのメソッドを使うことで自動的に処理できるケースが多い。なのでensure説を自分で書く前にそういった便利メソッドが用意されていないか公式リファレンスを確認する癖をつけるべし
- 例外処理のelse :cherries:p393 例外が発生しなかった場合の処理
- 例外処理と戻り値 :cherries:p394
- begin/endを省略するrescue修飾子 :cherries:p396
- $!と$@に格納される例外情報 :cherries:p397 可読性を考えると組み込み変数を使わない方が好ましい
- 例外処理のbegin/endを省略できるケース :cherries:p397
- rescueした例外を再度発生させる :cherries:p399 プログラム自体は異常終了させ、その情報はログに残したい時に使うテクニック
- 独自の例外クラスを定義する :cherries:p399


## 次やること

- プロを目指す人のためのRuby入門を読む、感想をブログに書く、URLを提出(537p,13章,1章:tomato:×2,1p=1~2min) 21:tomato:(累計16)(合計)
- SQL超入門コース 5:tomato:
- スッキリわかるSQL入門読む、記事作成、URL提出 21:tomato:
- :black_cat:
- 達人に学ぶDB設計 徹底指南書を読む、記事作成、URL提出 16:tomato:
- 課題:データベース設計の基本、twitterのER図作成 12:tomato:
- REST WebAPI サービス 設計 | Udemyを見る 9:tomato:

## 感じたこと

- 実際に手を動かしてトライアンドエラーを繰り返すことで誤った認識や仮定が現実に即したものになっていくと感じた

## 学習時間

- Today：12h
- Total：129h
